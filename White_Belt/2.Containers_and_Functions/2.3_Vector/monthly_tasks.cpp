#include <iostream>
#include <vector>

/*
У каждого из нас есть повторяющиеся ежемесячные дела, каждое из которых нужно выполнять 
в конкретный день каждого месяца: оплата счетов за электричество, абонентская плата за связь и пр. 
Вам нужно реализовать работу со списком таких дел на месяц, а именно, реализовать набор следующих операций:

ADD i s
Назначить дело с названием s на день i текущего месяца.

DUMP i
Вывести все дела, запланированные на день i текущего месяца.

NEXT
Перейти к списку дел на новый месяц. 
При выполнении данной команды вместо текущего (старого) списка дел на текущий месяц создаётся 
и становится активным (новый) список дел на следующий месяц: все дела со старого списка дел копируются в новый список. 
После выполнения данной команды новый список дел и следующий месяц становятся текущими, 
а работа со старым списком дел прекращается. 
При переходе к новому месяцу необходимо обратить внимание на разное количество дней в месяцах:

     - если следующий месяц имеет больше дней, чем текущий, 
     «дополнительные» дни необходимо оставить пустыми (не содержащими дел);

     - если следующий месяц имеет меньше дней, чем текущий, 
     меньше дней, дела со всех «лишних» дней необходимо переместить на последний день следующего месяца.

Замечания
    1) Историю списков дел хранить не требуется, работа ведется только с текущим списком дел текущего месяца. 
    Более того, при создании списка дел на следующий месяц, он «перетирает» предыдущий список.

    2) Обратите внимание, что количество команд NEXT в общей последовательности команд при работе со списком дел 
    может превышать 11.

    3) Начальным текущим месяцем считается январь.

    4) Количества дней в месяцах соответствуют Григорианскому календарю с той лишь разницей, 
    что в феврале всегда 28 дней.

Формат ввода
Сначала число операций Q, затем описания операций.

Названия дел s уникальны и состоят только из латинских букв, цифр и символов подчёркивания. 
Номера дней iявляются целыми числами и нумеруются от 1 до размера текущего месяца.

Формат вывода
Для каждой операции типа DUMP в отдельной строке выведите количество дел в соответствующий день, 
а затем их названия, разделяя их пробелом. Порядок вывода дел в рамках каждой операции значения не имеет.

Пример
Ввод

12
ADD 5 Salary
ADD 31 Walk
ADD 30 WalkPreparations
NEXT
DUMP 5
DUMP 28
NEXT
DUMP 31
DUMP 30
DUMP 28
ADD 28 Payment
DUMP 28
 

Вывод

1 Salary
2 WalkPreparations Walk
0
0
2 WalkPreparations Walk
3 WalkPreparations Walk Payment
 

Указание
Для дописывания всех элементов вектора v2 в конец вектора v1 удобно использовать метод insert:

v1.insert(end(v1), begin(v2), end(v2));

Кроме того, элементом вектора может быть любой тип, в том числе и другой вектор. 
Например, vector<vector<int>> — это вектор, элементами которого являются вектора целых чисел 
(то есть двумерный массив). 
Пример использования:

vector<vector<int>> m(10); // Создаём вектор из десяти векторов целых чисел
m[0].push_back(5);  // Добавляем элементы в первый вектор
m[0].push_back(15);
cout << m[0][1]; // Выведет 15 — второй элемент первого вектора

m[1].push_back(3);
for (int x : m[1]) {
    // Перебираем все элементы второго 
}
*/
int main() {
    std::vector<int> day_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int current_month = 0;
    std::vector<std::vector<std::string>> tasks(day_in_month[current_month]);

    int Q;
    std::cin >> Q;

    while(Q--) {
        std::string req;
        std::cin >> req;

        if (req == "ADD") {
            int day;
            std::string task;
            std::cin >> day >> task;
            tasks[day - 1].push_back(task);
        } else if (req == "DUMP") {
            int day;
            std::cin >> day;
            std::cout << tasks[day - 1].size();
            for (auto task : tasks[day - 1])
            {
                std::cout << ' ' << task;
            }
            std::cout << std::endl;
        } else if (req == "NEXT") {
            int next_month = (current_month + 1) % 12;
            int diff_days = day_in_month[next_month] - day_in_month[current_month];
            if (diff_days >= 0) {
                tasks.resize(tasks.size() + diff_days);
            } else {
                int last_day = tasks.size() - 1 - abs(diff_days);
                for (size_t i = last_day + 1; i < tasks.size(); ++i) {
                    tasks[last_day].insert(end(tasks[last_day]), begin(tasks[i]), end(tasks[i]));
                }
                tasks.resize(last_day + 1);
            }
            current_month = next_month;
        }
    }
    return 0;
}